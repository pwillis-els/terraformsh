#!/usr/bin/env bash
# terraformsh - Bash wrapper around Terraform
# Copyright (C) 2020-2021 Peter Willis

set -e -u -o pipefail
[ "${DEBUG:-0}" = "1" ] && set -x       # set DEBUG=1 to enable tracing
VERSION="0.11"

# ---------------------------------------------------------------------------------------- #
_usage () {
    cat <<EOTUSAGE
    terraformsh v$VERSION
    Usage: $0 [OPTIONS] [TFVARS] COMMAND [..]

# Options

  Pass these OPTIONS before any others (see examples); do not pass them after
  TFVARS or COMMANDs.

    -f FILE         A file passed to Terraform's -var-file option.
                    (config: VARFILES=)

    -b FILE         A file passed to Terraform's -backend-config option.
                    (config: BACKENDVARFILES=)

    -C DIR          Change to directory DIR.
                    (config: CD_DIR=)

    -c file         Specify a '.terraformshrc' configuration file to load

    -E EXPR         Evaluate an expression in bash ('eval EXPR').

    -I              Disables automatically loading any 'terraform.sh.tfvars',
                    'terraform.sh.tfvars.json', or 'backend.sh.tfvars' files 
                    found while recursively searching parent directories.
                    (config: INHERIT_TFFILES=0)

    -P              Do not use '.plan' files for plan/apply/destroy commands.
                    (config: USE_PLANFILE=0)

    -D              Don't run 'dependency' commands (e.g. don't run "terraform
                    init" before "terraform apply").
                    (config: NO_DEP_CMDS=1)

    -N              Dry-run mode (don't execute anything).
                    (config: DRYRUN=1)

    -v              Verbose mode.
                    (config: DEBUG=1)

    -h              This help screen

# Commands

  The following are commands that terraformsh provides wrappers for. Commands
  not listed here will be passed to terraform verbatim, along with any options.

    plan              Run init, get, validate, and \`terraform plan -out \$TF_PLANFILE\`
    apply             Run init, get, validate, and \`terraform apply \$TF_PLANFILE\`
    plan_destroy      Run init, get, validate, and \`terraform plan -destroy -out=\$TF_DESTROY_PLANFILE\`
    destroy           Run init, get, validate, and \`terraform apply \$TF_DESTROY_PLANFILE\`
    shell             Run init, get, and \`bash -i -l\`
    refresh           Run init, and \`terraform refresh\`
    validate          Run init, get, and \`terraform validate\`
    init              Run clean_modules, and \`terraform init\`
    clean             Remove '.terraform/modules/*', terraform.tfstate files, and .plan files
    clean_modules     Run \`rm -v -rf .terraform/modules/*\`
    approve           Prompts the user to approve the next step, or the program will exit with an error.
    aws_bootstrap     Looks for 'bucket' and 'dynamodb_table' in your '-b' file options.
                      If found, creates the bucket and table and initializes your Terraform state with them.
    import            Run \`terraform import [...]\`
    state             RUn \`terraform state [...]\`
EOTUSAGE
    exit 1
}
declare -a TF_COMMANDS=(0.12upgrade 0.13upgrade apply console debug destroy env fmt force-unlock get graph import init login logout output plan providers push refresh show state taint untaint validate version workspace)
declare -a WRAPPER_COMMANDS=(plan_destroy shell clean clean_modules approve aws_bootstrap)

# ---------------------------------------------------------------------------------------- #
# ------------------           functions                       --------------------------- #

_cmd_plan () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_validate
    _runcmd "$TERRAFORM" plan "${VARFILE_ARG[@]}" "${PLAN_ARGS[@]}"
}
_cmd_apply () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    _runcmd "$TERRAFORM" apply "${APPLY_ARGS[@]}" && rm -f "$TF_PLANFILE"
}
_cmd_plan_destroy () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_validate
    _runcmd "$TERRAFORM" plan "${VARFILE_ARG[@]}" -destroy "${PLANDESTROY_ARGS[@]}"
}
_cmd_destroy () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    if [ "${USE_PLANFILE:-0}" = "0" ] ; then
        _runcmd "$TERRAFORM" destroy "${DESTROY_ARGS[@]}"
    else
        _runcmd "$TERRAFORM" apply "${DESTROY_ARGS[@]}" && rm -f "$TF_DESTROY_PLANFILE"
    fi
}
# Validate doesn't require 'init' to check the .tf files syntax, but it does
# require init once it gets to the providers
_cmd_validate () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_get
    _runcmd "$TERRAFORM" validate "${VARFILE_ARG[@]}"
}
_cmd_get () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init # 'terraform get' does nothing if we have not initialized terraform
    _runcmd "$TERRAFORM" get "${GET_ARGS[@]}"
}
_cmd_refresh() {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    _runcmd "$TERRAFORM" refresh "${VARFILE_ARG[@]}" "${REFRESH_ARGS[@]}"
}
_cmd_0.12upgrade() {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    _runcmd "$TERRAFORM" 0.12upgrade "${OH12UPGRADE_ARGS[@]}"
}
_cmd_0.13upgrade() {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    _runcmd "$TERRAFORM" 0.13upgrade "${OH13UPGRADE_ARGS[@]}"
}
# Note: this line may need to be modified to pipe 'yes no | ' to the beginning 
# of the Terraform command, if you notice any problems with init in the future.
_cmd_init () {
    _runcmd "$TERRAFORM" init "${INIT_ARGS[@]}"
}
_cmd_import () {
    _runcmd "$TERRAFORM" import "${VARFILE_ARG[@]}" "${IMPORT_ARGS[@]}" "$@"
}
_cmd_state () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init 1>&2
    # 'terraform state' takes no options, but its commands do, so we play argument musical chairs
    declare -a _args=() _opts=("$@")
    _cmd=""
    if [ ${#_opts[@]} -gt 0 ] ; then
        _cmd="$1"; shift
        _args+=("${_opts[@]:1}")
    fi
    _runcmd "$TERRAFORM" state "$_cmd" "${STATE_ARGS[@]}" "${_args[@]}"
}
_cmd_catchall () {
    _runcmd "$TERRAFORM" "$@"
}
# The following allows you to do something like 'terraformsh plan shell' to drop
# into a shell in the working directory of the root module to be used, with
# everything ready to run 'terraform' commands (such as 'terraform state list')
_cmd_shell () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_get
    _runcmd bash -i -l
}
# This is basically in case the directory structure where this runs was changed
# after an initial terraform run. Terraform sucks at cleaning up broken symlinks
# and its modules.json, so unless we want to have a *ton* of complex logic here,
# just blow modules away every time.
_cmd_clean_modules () {
    _runcmd rm -v -rf .terraform/modules/*
}
_cmd_clean () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_clean_modules
    _runcmd rm -vrf "$TF_PLANFILE" "$TF_DESTROY_PLANFILE" .terraform/terraform.tfstate terraform.tfstate || true
}
_cmd_approve () {
    echo ""
    read -p "Are you SURE you want to continue with the next commands? Type 'YES' to continue: " APPROVE
    if [ "$APPROVE" = "YES" ] ; then
        echo "Approval given; continuing!"
    else
        echo "Approval not given; exiting!"
        exit 1
    fi
    echo ""
}
# This function is used to bootstrap a new AWS remote state file.
# You would typically run this in a brand new region, or for a brand new
# root module, to create the initial state file. It will attempt to re-use
# an existing S3 bucket and DynamoDB table, or create them if they don't
# yet exist.
_cmd_aws_bootstrap () {
    _cmd_clean_modules

    # Look though the backend var files for the backend bucket and dynamodb_table
    for varfile in "${BACKENDVARFILES[@]}" ; do
        BACKEND_BUCKET="$( grep -e "^[[:space:]]*bucket[[:space:]]\+=" < "$varfile" \
            | sed -e 's/^[[:space:]]*bucket[[:space:]]\+=[[:space:]]*//; s/^"//g; s/"$//g' )"
        BACKEND_TABLE="$( grep -e "^[[:space:]]*dynamodb_table[[:space:]]\+=" < "$varfile" \
            | sed -e 's/^[[:space:]]*dynamodb_table[[:space:]]\+=[[:space:]]*//; s/^"//g; s/"$//g' )"
    done

    if [ -z "${BACKEND_BUCKET:-}" ] || [ -z "${BACKEND_TABLE:-}" ] ; then
        echo "$0: Error: make sure 'bucket' and 'dynamodb_table' are set in your backend var files"
        exit 1
    fi

    # Set a local terraform backend
    printf "terraform {\n\tbackend local {}\n}\n" > terraform-backend.tf
    # First remove any existing previous local state
    _cmd_clean
    # Initialize local state
    _cmd_init

    # Attempt to import bucket if it exists
    BUCKET_REGION="$(aws s3api get-bucket-location \
        --bucket "${BACKEND_BUCKET}" --query LocationConstraint --output text \
        || true )"
    if [ -n "$BUCKET_REGION" ] ; then
        echo "$0: Info: importing existing S3 bucket '$BACKEND_BUCKET' ..." 1>&2
        _runcmd "$TERRAFORM" import "${IMPORT_ARGS[@]}" "${VARFILE_ARG[@]}" aws_s3_bucket.terraform_state "$BACKEND_BUCKET"
    else
        echo "$0: Info: Did not find existing S3 bucket '$BACKEND_BUCKET'; creating..." 1>&2
    fi

    # Attempt to import dynamodb table if it exists
    DYNAMODB_TABLE="$( aws dynamodb list-tables \
        | jq -re "select(.TableNames | index(\"$BACKEND_TABLE\")) | .TableNames[]" || true )"
    if [ -n "$DYNAMODB_TABLE" ] ; then
        echo "$0: Info: importing existing DynamoDB table '$BACKEND_TABLE' ..." 1>&2
        _runcmd "$TERRAFORM" import "${IMPORT_ARGS[@]}" "${VARFILE_ARG[@]}" aws_dynamodb_table.terraform_lock "$BACKEND_TABLE" || true
    else
        echo "$0: Info: Did not find backend table '$BACKEND_TABLE'; creating..." 1>&2
    fi

    # Plan & Apply to create the dynamodb table and s3 bucket
    _runcmd "$TERRAFORM" plan -input=false "${VARFILE_ARG[@]}" \
        -target aws_dynamodb_table.terraform_lock \
        -target aws_s3_bucket.terraform_state \
        -out "$TF_BOOTSTRAP_PLANFILE"
    _runcmd "$TERRAFORM" apply -input=false "$TF_BOOTSTRAP_PLANFILE"

    # Set an s3 terraform backend
    printf "terraform {\n\tbackend s3 {}\n}\n" > terraform-backend.tf

    echo "Sleeping 60 seconds before querying bucket again ..." 1>&2
    sleep 60

    _runcmd "$TERRAFORM" init "${INIT_ARGS[@]}" "${BACKENDVARFILE_ARG[@]}"
}
_cleanup_tmp () { 
    if [ -n "${TF_TMPDIR:-}" ]; then rm -rf "$TF_TMPDIR"; fi
}
_tf_set_datadir () {
    # Generate a temporary, but predictable, TF_DATA_DIR, if not set yet
    if [ -z "${TF_DATA_DIR:-}" ] ; then
        _cleanup_tmp
        if [ -z "${TF_DD_UNIQUE_NAME:-}" ] ; then
            # Generate a truncated MD5 hash based on the name of both the directory where
            # we ran terraformsh from, and any '-C' option (the root module). This way we
            # can run 'terraformsh' from the same directory on multiple root modules, and
            # they will each end up with a different TF_DATA_DIR.
            TF_DD_UNIQUE_NAME="$(printf "%s\n%s\n" "$TERRAFORM_PWD" "$TERRAFORM_MODULE_PWD" | md5sum - | awk '{print $1}' | cut -b 1-10)"
        fi
        export TF_TMPDIR="${TMPDIR:-/tmp}/tfsh.$TF_DD_UNIQUE_NAME"
        mkdir -p "$TF_TMPDIR"
        trap _cleanup_tmp EXIT
        export TF_DATA_DIR="$TF_TMPDIR"
    fi
}
_default_vars () {
    # Help load AWS credentials, and silence some messages for automation.
    AWS_SDK_LOAD_CONFIG="${AWS_SDK_LOAD_CONFIG:-1}"
    TF_IN_AUTOMATION="${TF_IN_AUTOMATION:-1}"

    export AWS_SDK_LOAD_CONFIG TF_IN_AUTOMATION

    # Override these variables to change the config files that are automatically loaded
    # when found in any parent directories (disable with the '-I' option).
    TF_BACKEND_AUTO_CONFIG_FILE="${TF_BACKEND_AUTO_CONFIG_FILE:-backend.sh.tfvars}"
    TF_AUTO_CONFIG_FILE="${TF_AUTO_CONFIG_FILE:-terraform.sh.tfvars}"

    # This enables the above functionality by default ('-I' sets this to 0)
    INHERIT_TFFILES="${INHERIT_TFFILES:-1}"

    CD_DIR=""
    USE_PLANFILE="${USE_PLANFILE:-1}"
    TERRAFORM="${TERRAFORM:-terraform}" # the terraform executable
    PLAN_ARGS=("-input=false")
    APPLY_ARGS=("-input=false")
    PLANDESTROY_ARGS=("-input=false")
    DESTROY_ARGS=("-input=false")
    REFRESH_ARGS=("-input=false")
    OH12UPGRADE_ARGS=("-yes")
    OH13UPGRADE_ARGS=("-yes")
    INIT_ARGS=("-input=false" "-reconfigure" "-force-copy")
    IMPORT_ARGS=("-input=false")
    GET_ARGS=("-update=true")
    STATE_ARGS=()

    TERRAFORM_PWD="$(pwd)"
}
_pre_dirchange_vars () {
    if [ ${#VARFILES[@]} -gt 0 ] ; then
        for arg in "${VARFILES[@]}" ; do
            VARFILE_ARG+=("-var-file" "$(_readlinkf "$arg")")
        done
    fi
    if [ ${#BACKENDVARFILES[@]} -gt 0 ] ; then
        for arg in "${BACKENDVARFILES[@]}" ; do
            BACKENDVARFILE_ARG+=("-backend-config" "$(_readlinkf "$arg")")
        done
    fi
}
_final_vars () {
    TERRAFORM_MODULE_PWD="$(pwd)"
    _tf_set_datadir

    # Override these to change the name of the plan files
    TF_PLANFILE="${TF_PLANFILE:-${TERRAFORM_PWD}/tf.$TF_DD_UNIQUE_NAME.plan}"
    TF_DESTROY_PLANFILE="${TF_DESTROY_PLANFILE:-${TERRAFORM_PWD}/tf-destroy.$TF_DD_UNIQUE_NAME.plan}"
    TF_BOOTSTRAP_PLANFILE="${TF_BOOTSTRAP_PLANFILE:-${TERRAFORM_PWD}/tf-bootstrap.$TF_DD_UNIQUE_NAME.plan}"

    if [ "$USE_PLANFILE" -eq 1 ] ; then
        PLAN_ARGS+=("-out=$TF_PLANFILE")
        APPLY_ARGS+=("$TF_PLANFILE")
        PLANDESTROY_ARGS+=("-out=$TF_DESTROY_PLANFILE")
        DESTROY_ARGS+=("$TF_DESTROY_PLANFILE")
    fi
    if [ ${#BACKENDVARFILE_ARG[@]} -lt 1 ] ; then
        echo "$0: WARNING: No -b option passed! Potentially using only local state." 1>&2
        echo "" 1>&2
        sleep 1
    else
        INIT_ARGS+=("${BACKENDVARFILE_ARG[@]}")
    fi
}
_load_conf () {
    # Don't load the default configs if one was passed via '-c'
    if [ ${#CONF_FILE[@]} -lt 1 ] ; then
        for f in "/etc/terraformsh" ~/.terraformshrc "./.terraformshrc" "terraformsh.conf" ; do
            [ -r "$f" ] && . "$(_readlinkf "$f")"
        done
    # If '-c' was passed, let the user pass only the configs they want to load.
    elif [ ${#CONF_FILE[@]} -gt 0 ] ; then
        for conf in "${CONF_FILE[@]}" ; do
            # NOTE: This is not a replacement for 'readlink -f'; if you want
            # that behavior, pass the real file path yourself, don't rely on this.
            . "$(_readlinkf "$conf")"
        done
    fi
    return 0
}
_load_parent_tffiles () {
    if [ "${INHERIT_TFFILES:-0}" = "1" ] ; then
        while read -r LINE ; do VARFILES=("$LINE" "${VARFILES[@]}") ; done < <( _rfindfiles "$TF_AUTO_CONFIG_FILE" )
        while read -r LINE ; do VARFILES=("$LINE" "${VARFILES[@]}") ; done < <( _rfindfiles "$TF_AUTO_CONFIG_FILE.json" )
        while read -r LINE ; do BACKENDVARFILES=("$LINE" "${BACKENDVARFILES[@]}") ; done < <( _rfindfiles "$TF_BACKEND_AUTO_CONFIG_FILE" )
    fi
}
_process_cmds () {
    declare -a tmpcmds=()
    for cmd in "${CMDS[@]}" ; do
        # If a config file was passed as a command, add them as options
        if    [ ! "$(expr "$cmd" : ".*\.backend\.tfvars$")" = "0" ] \
              || [ ! "$(expr "$cmd" : ".*\.backend\.sh\.tfvars$")" = "0" ] \
              || [ ! "$(expr "$cmd" : ".*\.backend$")" = "0" ]
        then  BACKENDVARFILES+=("$(_readlinkf "$cmd")")

        elif  [ "$(expr "$cmd" : ".*\.tfvars$")" -ne 0 ] \
              || [ "$(expr "$cmd" : ".*\.sh\.tfvars$")" -ne 0 ] \
              || [ "$(expr "$cmd" : ".*\.tfvars\.json$")" -ne 0 ] \
              || [ "$(expr "$cmd" : ".*\.sh\.tfvars\.json$")" -ne 0 ]
        then  VARFILES+=("$(_readlinkf "$cmd")")

        else
            valid_cmd=0
            for possiblecmd in "${TF_COMMANDS[@]}" "${WRAPPER_COMMANDS[@]}" ; do
                if [ "$possiblecmd" = "$cmd" ] ; then
                  tmpcmds+=("$cmd") ; valid_cmd=1 ; break
                fi
            done
            if [ $valid_cmd -eq 0 ] ; then
                echo "$0: WARNING: '$cmd' is not a valid command; passing as an option instead" 1>&2
                OPTS+=("$cmd")
            fi
        fi
    done
    CMDS=("${tmpcmds[@]}")
    if [ ${#CMDS[@]} -lt 1 ] ; then
        echo "$0: Error: No COMMAND was specified"
        echo ""
        _usage
    fi
    if [ ${#CMDS[@]} -gt 1 ] && [ ${#OPTS[@]} -gt 0 ] ; then
        echo "$0: Error: you passed multiple commands with some non-command arguments; you can only pass non-command arguments with a single valid command."
        exit 1
    fi
}
_dirchange () {
    # Change to directories
    if [ -n "${CD_DIR:-}" ] ; then
        printf "+ cd \"%s\"\n" "$CD_DIR" 1>&2
        cd "$CD_DIR"
    fi
}
_readlinkf () {
    [ "${1:-}" ] || return 1; m_s=40; CDPATH=''; t=$1; [ -e "${t%/}" ] || t=${1%"${1##*[!/]}"}
    [ -d "${t:-/}" ] && t="$t/"; cd -P . 2>/dev/null || return 1; 
    while [ "$m_s" -ge 0 ] && m_s=$((m_s - 1)); do
      if [ ! "$t" = "${t%/*}" ]; then case $t in 
        /*) cd -P "${t%/*}/"  || break ;;
        *) cd -P "./${t%/*}"  || break ;;
        esac; t=${t##*/}; fi
      if [ ! -L "$t" ]; then t="${PWD%/}${t:+/}${t}"; printf '%s\n' "${t:-/}"; return 0; fi
      link=$(ls -dl -- "$t" 2>/dev/null) || break; t=${link#*" $t -> "}
    done; return 1
}
_rfindfiles () {
    local file="$1"
    cwd="$(pwd)"
    while [ ! "$(dirname "$cwd")" = "/" ] ; do
        if [ -r "$cwd/$file" ] ; then
            printf "%s\n" "$cwd/$file"
        fi
        cwd="$(dirname "$cwd")"
    done
}
_runcmd () {
    echo "+ $*" 1>&2
    if [ ! "${DRYRUN:-0}" = "1" ] ; then "$@"; fi
}

# ---------------------------------------------------------------------------------------- #
# ------------------           parse cmdline options           --------------------------- #

SHOW_HELP=0
declare -a BACKENDVARFILE_ARG=() BACKENDVARFILES=() VARFILE_ARG=() VARFILES=() 
declare -a REFRESH_ARGS=() INIT_ARGS=() IMPORT_ARGS=() GET_ARGS=() STATE_ARGS=()
declare -a PLAN_ARGS=() APPLY_ARGS=() PLANDESTROY_ARGS=() DESTROY_ARGS=()
declare -a CMDS=() CONF_FILE=()

_default_vars

while getopts "f:b:C:c:E:IPDNhv" args ; do
    case $args in
        f)  VARFILES+=("$(_readlinkf "$OPTARG")") ;;
        b)  BACKENDVARFILES+=("$(_readlinkf "$OPTARG")") ;;
        C)  CD_DIR="$OPTARG" ;;
        c)  CONF_FILE+=("$OPTARG") ;;
        E)  eval "$OPTARG" ;;
        I)  INHERIT_TFFILES=0 ;;
        P)  USE_PLANFILE=0 ;;
        D)  NO_DEP_CMDS=1 ;;
        N)  DRYRUN=1 ;;
        h)  SHOW_HELP=1 ;;
        v)  export DEBUG=1 ;;
        *)
            echo "$0: Error: unknown option $args" ;
            exit 1 ;;
    esac
done
shift $(($OPTIND-1))

[ $SHOW_HELP -eq 1 ] && _usage

# ---------------------------------------------------------------------------------------- #
# --------------------         run the commands            ------------------------------- #

[ "${DEBUG:-0}" = "1" ] && set -x

_load_parent_tffiles
_load_conf

[ ${#CMDS[@]} -eq 0 ] && CMDS=("$@")

declare -a OPTS=()
_process_cmds
_pre_dirchange_vars
_dirchange
_final_vars

for name in "${CMDS[@]}" ; do
    if command -v _cmd_"$name" >/dev/null ; then
        _cmd_"$name" "${OPTS[@]}"
    else 
        _cmd_catchall "$name" "${OPTS[@]}"
    fi
done
