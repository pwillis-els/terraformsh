#!/usr/bin/env bash
# terraformsh - Bash wrapper around Terraform
# Copyright (C) 2020-2021 Peter Willis

set -e -u -o pipefail
[ "${DEBUG:-0}" = "1" ] && set -x       # set DEBUG=1 to enable tracing
VERSION="0.12"

# ---------------------------------------------------------------------------------------- #
_usage () {
    cat <<EOTUSAGE
    terraformsh v$VERSION
    Usage: $0 [OPTIONS] [TFVARS] COMMAND [..]

# Options

  Pass these OPTIONS before any others (see examples); do not pass them after
  TFVARS or COMMANDs.

    -f FILE         A file passed to Terraform's -var-file option.
                      ( config: VARFILES= )
    -b FILE         A file passed to Terraform's -backend-config option.
                      ( config: BACKENDVARFILES= )
    -C DIR          Change to directory DIR.
                      ( config: CD_DIR= )
    -c file         Specify a '.terraformshrc' configuration file to load.
    -E EXPR         Evaluate an expression in bash ('eval EXPR').
    -I              Disables automatically loading any 'terraform.sh.tfvars',
                    'terraform.sh.tfvars.json', or 'backend.sh.tfvars' files
                    found while recursively searching parent directories.
                      ( config: INHERIT_TFFILES=0 )
    -P              Do not use '.plan' files for plan/apply/destroy commands.
                      ( config: USE_PLANFILE=0 )
    -D              Don't run 'dependency' commands (e.g. don't run "terraform
                    init" before "terraform apply").
                      ( config: NO_DEP_CMDS=1 )
    -N              Dry-run mode (don't execute anything).
                      ( config: DRYRUN=1 )
    -n              Don't remove the temporary TF_DATA_DIR.
                      ( config: NO_CLEANUP_TMP=1 )
    -v              Verbose mode.
                      ( config: DEBUG=1 )
    -h              This help screen.

# Commands

  The following are Terraform commands that terraformsh provides wrappers for
  (there's some Terraformsh-specific logic behind the scenes). Other Terraform
  commands not listed here are passed through to Terraform verbatim.

    plan              Run init, get, validate, \`terraform plan @VARFILE_ARG -out \$TF_PLANFILE\`
    apply             Run init, get, validate, \`terraform apply \$TF_PLANFILE\`
    plan_destroy      Run init, get, validate, \`terraform plan -destroy -out=\$TF_DESTROY_PLANFILE\`
    destroy           Run init, get, validate, \`terraform apply \$TF_DESTROY_PLANFILE\`
    refresh           Run init, \`terraform refresh\`
    validate          Run init, get, \`terraform validate\`
    init              Run clean_modules, \`terraform init @BACKENDVARFILE_ARG\`
    get               Run init, \`terraform get [..]\`
    show              Run init, \`terraform show [..]\`
    import            Run init, \`terraform import [..]\`
    state             Run init, \`terraform state [..]\`
    taint             Run init, \`terraform taint [..]\`
    untaint           Run init, \`terraform untaint [..]\`
    output            Run init, refresh, \`terraform output [..]\`
    console           Run init, \`terraform console [..]\`
    workspace         Run init, \`terraform workspace [..]\`
    force-unlock      Run init, \`terraform force-unlock [..]\`
    0.12upgrade       Run init, \`terraform 0.12upgrade [..]\`
    0.13upgrade       Run init, \`terraform 0.13upgrade [..]\`

  The following commands are specific to terraformsh:

    shell             Run init, get, and \`bash -i -l\`
    clean             Remove '.terraform/modules/*', terraform.tfstate files, and .plan files
    clean_modules     Run \`rm -v -rf .terraform/modules/*\`
    approve           Prompts the user to approve the next step, or the program will exit with an error.
    aws_bootstrap     Looks for 'bucket' and 'dynamodb_table' in your '-b' file options.
                      If found, creates the bucket and table and initializes your Terraform state with them.

All arguments after a COMMAND are evaluated for whether they match a Terraform
or Terraformsh command; if they don't, they are assumed to be options and are
passed to the first recognized command that precedes them.
EOTUSAGE
    exit 1
}
# Commands collected from versions 0.11,0.12,0.13,0.14,0.15,1.0,1.1
declare -a TF_COMMANDS=(0.12checklist 0.12upgrade 0.13upgrade apply console debug destroy env fmt force-unlock get graph import init login logout output plan providers push refresh show state taint test untaint validate version workspace)
declare -a TF_CMDS_debug=(json2dot)
declare -a TF_CMDS_env=(delete list new select)
declare -a TF_CMDS_providers=(lock mirror schema)
declare -a TF_CMDS_state=(list mv pull push replace-provider rm show)
declare -a TF_CMDS_workspace=(delete list new select show)
declare -a WRAPPER_COMMANDS=(plan_destroy shell clean clean_modules approve aws_bootstrap)

# ---------------------------------------------------------------------------------------- #
# ------------------           functions                       --------------------------- #

_cmd_plan () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_validate
    declare -a args=("$@")
    [ $USE_PLANFILE -eq 1 ] && args+=("-out=$TF_PLANFILE")
    _runcmd "$TERRAFORM" plan "${VARFILE_ARG[@]}" "${PLAN_ARGS[@]}" "${args[@]}"
}
_cmd_apply () {
    local errored=0
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    [ $USE_PLANFILE -eq 1 ] && args+=("$TF_PLANFILE") # Pass plan file after '$@'
    [ ! -e errored.tfstate ] || errored=1 # Ignore pre-existing errored.tfstate
    if ! _runcmd "$TERRAFORM" apply "${APPLY_ARGS[@]}" "${args[@]}" ; then
        if [ "${PUSH_ERRORED_TFSTATE:-1}" -eq 1 ] && [ $errored -eq 0 ] && [ -e errored.tfstate ] ; then
            echo "$0: Warning: found 'errored.tfstate' after running 'apply'; attempting to push unapplied state file..."
            if _cmd_state push errored.tfstate ; then
                rm -f errored.tfstate
            else
                echo "$0: Error: could not push errored.tfstate!" ; exit 1
            fi
        fi
    else
        rm -f "$TF_PLANFILE"
    fi
}
_cmd_plan_destroy () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_validate
    declare -a args=("$@")
    [ $USE_PLANFILE -eq 1 ] && args+=("-out=$TF_DESTROY_PLANFILE")
    _runcmd "$TERRAFORM" plan "${VARFILE_ARG[@]}" -destroy "${PLANDESTROY_ARGS[@]}" "${args[@]}"
}
_cmd_destroy () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    if [ "${USE_PLANFILE:-0}" = "0" ] ; then
        _runcmd "$TERRAFORM" destroy "${args[@]}" "${DESTROY_ARGS[@]}"
    else
        args+=("$TF_DESTROY_PLANFILE") # Pass plan file after '$@'
        _runcmd "$TERRAFORM" apply "${DESTROY_ARGS[@]}" "${args[@]}" && rm -f "$TF_DESTROY_PLANFILE"
    fi
}
# Validate doesn't require 'init' to check the .tf files syntax, but it does
# require init once it gets to the providers
_cmd_validate () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_get
    declare -a args=("$@")
    declare -a tfver_a=($(_tf_ver))
    # If terraform version < 0.12, pass VARFILE_ARG to validate. Otherwise it's deprecated
    if [ "${tfver_a[0]:-}" = "0" ] && [ ${tfver_a[1]:-} -lt 12 ] ; then
        args+=("${VARFILE_ARG[@]}")
    fi
    _runcmd "$TERRAFORM" validate "${VALIDATE_ARGS[@]}" "${args[@]}"
}
_cmd_get () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init # 'terraform get' does nothing if we have not initialized terraform
    declare -a args=("$@")
    _runcmd "$TERRAFORM" get "${GET_ARGS[@]}" "${args[@]}"
}
_cmd_refresh () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" refresh "${VARFILE_ARG[@]}" "${REFRESH_ARGS[@]}" "${args[@]}"
}
_cmd_output () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_refresh 1>&2 # Send all previous command output to STDERR
    declare -a args=("$@")
    _runcmd "$TERRAFORM" output "${OUTPUT_ARGS[@]}" "${args[@]}"
}
_cmd_force-unlock () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" force-unlock "${FORCEUNLOCK_ARGS[@]}" "${args[@]}"
}
_cmd_0.12upgrade () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" 0.12upgrade "${OH12UPGRADE_ARGS[@]}" "${args[@]}"
}
_cmd_0.13upgrade () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" 0.13upgrade "${OH13UPGRADE_ARGS[@]}" "${args[@]}"
}
_cmd_console () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" console "${VARFILE_ARG[@]}" "${CONSOLE_ARGS[@]}" "${args[@]}"
}
# Note: this line may need to be modified to pipe 'yes no | ' to the beginning
# of the Terraform command, if you notice any problems with init in the future.
_cmd_init () {
    [ "${_already_ran_cmd_init:-0}" = "1" ] && return 0
    _already_ran_cmd_init=1
    declare -a args=("$@")
    _runcmd "$TERRAFORM" init "${INIT_ARGS[@]}" "${args[@]}"
}
_cmd_import () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" import "${VARFILE_ARG[@]}" "${IMPORT_ARGS[@]}" "${args[@]}"
}
_cmd_taint () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" taint "${TAINT_ARGS[@]}" "${args[@]}"
}
_cmd_untaint () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init
    declare -a args=("$@")
    _runcmd "$TERRAFORM" untaint "${UNTAINT_ARGS[@]}" "${args[@]}"
}
_cmd_state () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init 1>&2 # Send all previous command output to STDERR
    declare -a args=()
    local cmd
    # 'terraform state' takes no options, but its commands do, so we play argument musical chairs
    # so that the options come after the sub-command, not after 'terraform state'.
    if [ $# -gt 0 ] ; then
        cmd="$1"; shift
        args+=("$cmd")
    fi
    # add '-backup=' to 'terraform state rm ...' command
    if [ "${cmd:-}" = "rm" ] ; then
        # shellcheck disable=SC2155
        local backupstate="$(mktemp -p "$TERRAFORM_PWD" "backup.XXXXXXXXXX.tfstate")"
        args+=("-backup=$backupstate")
        [ "${DRYRUN:-0}" = "1" ] && rm -f "$backupstate"
    fi
    args+=("${STATE_ARGS[@]}")
    args+=("$@")
    _runcmd "$TERRAFORM" state "${args[@]}"
}
_cmd_workspace () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init 1>&2
    declare -a args=()
    local cmd
    if [ $# -gt 0 ] ; then
        # 'terraform workspace' takes no options, but its commands do, so we play argument musical chairs
        cmd="$1"; shift
        args+=("$cmd")
    fi
    args+=("${WORKSPACE_ARGS[@]}")
    args+=("$@")
    _runcmd "$TERRAFORM" workspace "${args[@]}"
}
_cmd_show () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_init 1>&2 # Send all previous command output to STDERR
    declare -a args=("$@")
    _runcmd "$TERRAFORM" show "${SHOW_ARGS[@]}" "${args[@]}"
}
_cmd_catchall () {
    _runcmd "$TERRAFORM" "$@"
}
# The following allows you to do something like 'terraformsh plan shell' to drop
# into a shell in the working directory of the root module to be used, with
# everything ready to run 'terraform' commands (such as 'terraform state list')
_cmd_shell () {
    ret=0
    if [ "${NO_DEP_CMDS:-0}" = "0" ] && ! _cmd_get ; then
        ret=$?
        echo "$0: Previous command failed!"
    fi
    echo "$0: Dropping into shell; see TF_DATA_DIR variable for temp files"
    _runcmd bash -i -l
    return $?
}
# This is basically in case the directory structure where this runs was changed
# after an initial terraform run. Terraform sucks at cleaning up broken symlinks
# and its modules.json, so unless we want to have a *ton* of complex logic here,
# just blow modules away every time.
_cmd_clean_modules () {
    _runcmd rm -v -rf .terraform/modules/*
}
_cmd_clean () {
    [ "${NO_DEP_CMDS:-0}" = "0" ] && _cmd_clean_modules
    _runcmd rm -vrf "$TF_PLANFILE" "$TF_DESTROY_PLANFILE" .terraform/terraform.tfstate terraform.tfstate || true
}
_cmd_approve () {
    local approve
    echo ""
    read -p "$0: Are you SURE you want to continue with the next commands? Type 'YES' to continue: " approve
    if [ "$approve" = "YES" ] ; then
        echo "$0: Approval given; continuing!" ; echo ""
    else
        echo "$0: Approval not given; exiting!" ; exit 1
    fi
}
# This function is used to bootstrap a new AWS remote state file.
# You would typically run this in a brand new region, or for a brand new
# root module, to create the initial state file. It will attempt to re-use
# an existing S3 bucket and DynamoDB table, or create them if they don't
# yet exist.
_cmd_aws_bootstrap () {
    local bucket_region
    _cmd_clean_modules

    # Look though the backend var files for the backend bucket and dynamodb_table
    for varfile in "${BACKENDVARFILES[@]}" ; do
        TF_BACKEND_BUCKET="${TF_BACKEND_BUCKET:-$( grep -e "^[[:space:]]*bucket[[:space:]]\+=" < "$varfile" | sed -E 's/^[[:space:]]*bucket[[:space:]]+=[[:space:]]*//; s/^"//g; s/"$//g' )}"
        TF_BACKEND_TABLE="${TF_BACKEND_TABLE:-$( grep -e "^[[:space:]]*dynamodb_table[[:space:]]\+=" < "$varfile" | sed -E 's/^[[:space:]]*dynamodb_table[[:space:]]+=[[:space:]]*//; s/^"//g; s/"$//g' )}"
    done

    if [ -z "${TF_BACKEND_BUCKET:-}" ] || [ -z "${TF_BACKEND_TABLE:-}" ] ; then
        echo "$0: Error: Make sure 'bucket' and 'dynamodb_table' are set in your backend var files"
        exit 1
    fi

    # Create a local terraform backend
    printf "terraform {\n\tbackend local {}\n}\n" > terraformsh-backend.tf

    # First remove any existing previous local state
    _cmd_clean
    # Initialize local state
    _cmd_init

    # Attempt to import bucket if it exists
    bucket_region="$(aws s3api get-bucket-location \
        --bucket "${TF_BACKEND_BUCKET}" --query LocationConstraint --output text \
        || true )"
    if [ -n "$bucket_region" ] ; then
        echo "$0: Info: importing existing S3 bucket '$TF_BACKEND_BUCKET' ..." 1>&2
        _runcmd "$TERRAFORM" import "${IMPORT_ARGS[@]}" "${VARFILE_ARG[@]}" aws_s3_bucket.terraform_state "$TF_BACKEND_BUCKET"
    else
        echo "$0: Info: Did not find existing S3 bucket '$TF_BACKEND_BUCKET'; creating..." 1>&2
    fi

    # Attempt to import dynamodb table if it exists
    # TODO: replace 'jq' here with a --query in the AWS CLI
    DYNAMODB_TABLE="$( aws dynamodb list-tables | jq -re "select(.TableNames | index(\"$TF_BACKEND_TABLE\")) | .TableNames[]" || true )"
    if [ -n "$DYNAMODB_TABLE" ] ; then
        echo "$0: Info: importing existing DynamoDB table '$TF_BACKEND_TABLE' ..." 1>&2
        _runcmd "$TERRAFORM" import "${IMPORT_ARGS[@]}" "${VARFILE_ARG[@]}" aws_dynamodb_table.terraform_lock "$TF_BACKEND_TABLE" || true
    else
        echo "$0: Info: Did not find backend table '$TF_BACKEND_TABLE'; creating..." 1>&2
    fi

    # Plan & Apply to create the dynamodb table and s3 bucket
    _runcmd "$TERRAFORM" plan -input=false "${VARFILE_ARG[@]}" \
        -target aws_dynamodb_table.terraform_lock \
        -target aws_s3_bucket.terraform_state \
        -out "$TF_BOOTSTRAP_PLANFILE"
    _runcmd "$TERRAFORM" apply -input=false "$TF_BOOTSTRAP_PLANFILE"

    # Create an s3 terraform backend
    printf "terraform {\n\tbackend s3 {}\n}\n" > terraformsh-backend.tf

    echo "$0: Sleeping 60 seconds before querying bucket again ..." 1>&2
    sleep 60

    _runcmd "$TERRAFORM" init "${INIT_ARGS[@]}" "${BACKENDVARFILE_ARG[@]}"
}

_cleanup_tmp () {
    if [ "${NO_CLEANUP_TMP_ON_ERROR:-0}" = "1" ] ; then
        echo "$0: Error detected; not removing '${TF_TMPDIR:-}'"
    else
        if [ "${NO_CLEANUP_TMP:-0}" = "1" ] ; then
            echo "$0: Not removing temporary TF_DATA_DIR '${TF_TMPDIR:-}'"
        elif [ -n "${TF_TMPDIR:-}" ] ; then
            rm -rf "$TF_TMPDIR"
        fi
    fi
}
_tf_ver () {
    local tf_ver
    tf_ver="$($TERRAFORM --version | grep '^Terraform v' | cut -d 'v' -f 2)"
    if [ $? -ne 0 ] ; then
        echo "$0: Error: 'terraform --version' failed?" 1>&2
        return 1
    fi
    IFS=. read -r -a tfver_a <<< "${tf_ver}"
    printf "%s\n" "${tfver_a[@]}"
}
_tf_set_datadir () {
    # Generate a temporary, but predictable, TF_DATA_DIR, if not set yet
    if [ -z "${TF_DD_UNIQUE_NAME:-}" ] ; then
        # Generate a truncated MD5 hash based on the name of both the directory where
        # we ran terraformsh from, and any '-C' option (the root module). This way we
        # can run 'terraformsh' from the same directory on multiple root modules, and
        # they will each end up with a different TF_DATA_DIR.
        TF_DD_UNIQUE_NAME="$(printf "%s\n%s\n" "$TERRAFORM_PWD" "$TERRAFORM_MODULE_PWD" | md5sum - | awk '{print $1}' | cut -b 1-10)"
    fi
    if [ -z "${TF_DATA_DIR:-}" ] ; then
        if [ -n "${TF_TMPDIR:-}" ] ; then
            echo "$0: Warning: A 'TF_TMPDIR' environment variable is already set! Are you running inside a 'terraform shell' session? You might want to exit your shell before running terraformsh again"
        fi
        _cleanup_tmp
        export TF_TMPDIR="${TMPDIR:-/tmp}/tfsh.$TF_DD_UNIQUE_NAME"
        mkdir -p "$TF_TMPDIR"
        trap _cleanup_tmp EXIT
        export TF_DATA_DIR="$TF_TMPDIR"
    fi
}
_default_vars () {
    # Help load AWS credentials, and silence some messages for automation.
    AWS_SDK_LOAD_CONFIG="${AWS_SDK_LOAD_CONFIG:-1}"
    TF_IN_AUTOMATION="${TF_IN_AUTOMATION:-1}"

    export AWS_SDK_LOAD_CONFIG TF_IN_AUTOMATION

    # Override these variables to change the config files that are automatically loaded
    # when found in any parent directories (disable with the '-I' option).
    TF_BACKEND_AUTO_CONFIG_FILE="${TF_BACKEND_AUTO_CONFIG_FILE:-backend.sh.tfvars}"
    TF_AUTO_CONFIG_FILE="${TF_AUTO_CONFIG_FILE:-terraform.sh.tfvars}"

    # This enables the above functionality by default ('-I' sets this to 0)
    INHERIT_TFFILES="${INHERIT_TFFILES:-1}"

    CD_DIR=""
    USE_PLANFILE="${USE_PLANFILE:-1}"
    TERRAFORM="${TERRAFORM:-terraform}" # the terraform executable
    PLAN_ARGS=("-input=false")
    APPLY_ARGS=("-input=false")
    PLANDESTROY_ARGS=("-input=false")
    DESTROY_ARGS=("-input=false")
    REFRESH_ARGS=("-input=false")
    OH12UPGRADE_ARGS=("-yes")
    OH13UPGRADE_ARGS=("-yes")
    INIT_ARGS=("-input=false" "-reconfigure" "-force-copy")
    IMPORT_ARGS=("-input=false")
    GET_ARGS=("-update=true")
    VALIDATE_ARGS=()
    STATE_ARGS=()
    WORKSPACE_ARGS=()
    CONSOLE_ARGS=()
    OUTPUT_ARGS=()
    TAINT_ARGS=()
    UNTAINT_ARGS=()
    FORCEUNLOCK_ARGS=("-force")
    SHOW_ARGS=()

    TERRAFORM_PWD="$(pwd)"
}
_pre_dirchange_vars () {
    if [ ${#VARFILES[@]} -gt 0 ] ; then
        for arg in "${VARFILES[@]}" ; do
            VARFILE_ARG+=("-var-file" "$(_readlinkf "$arg")")
        done
    fi
    if [ ${#BACKENDVARFILES[@]} -gt 0 ] ; then
        for arg in "${BACKENDVARFILES[@]}" ; do
            BACKENDVARFILE_ARG+=("-backend-config" "$(_readlinkf "$arg")")
        done
    fi
}
_final_vars () {
    TERRAFORM_MODULE_PWD="$(pwd)"
    _tf_set_datadir

    # Override these to change the name of the plan files
    TF_PLANFILE="${TF_PLANFILE:-${TERRAFORM_PWD}/tf.$TF_DD_UNIQUE_NAME.plan}"
    TF_DESTROY_PLANFILE="${TF_DESTROY_PLANFILE:-${TERRAFORM_PWD}/tf-destroy.$TF_DD_UNIQUE_NAME.plan}"
    TF_BOOTSTRAP_PLANFILE="${TF_BOOTSTRAP_PLANFILE:-${TERRAFORM_PWD}/tf-bootstrap.$TF_DD_UNIQUE_NAME.plan}"

    if [ ${#BACKENDVARFILE_ARG[@]} -lt 1 ] ; then
        echo "$0: Warning: No -b option passed! Potentially using only local state." 1>&2
        echo "" 1>&2
        sleep 1
    else
        INIT_ARGS+=("${BACKENDVARFILE_ARG[@]}")
    fi
}
_load_conf () {
    # Don't load the default configs if one was passed via '-c'
    if [ ${#CONF_FILE[@]} -lt 1 ] ; then
        for f in "/etc/terraformsh" ~/.terraformshrc "./.terraformshrc" "terraformsh.conf" ; do
            [ -e "$f" ] && . "$(_readlinkf "$f")"
        done
    # If '-c' was passed, let the user pass only the configs they want to load.
    elif [ ${#CONF_FILE[@]} -gt 0 ] ; then
        for conf in "${CONF_FILE[@]}" ; do
            # NOTE: This is not a replacement for 'readlink -f'; if you want
            # that behavior, pass the real file path yourself, don't rely on this.
            . "$(_readlinkf "$conf")"
        done
    fi
    return 0
}
_load_parent_tffiles () {
    if [ "${INHERIT_TFFILES:-0}" = "1" ] ; then
        while read -r LINE ; do VARFILES=("$LINE" "${VARFILES[@]}") ; done < <( _rfindfiles "$TF_AUTO_CONFIG_FILE" )
        while read -r LINE ; do VARFILES=("$LINE" "${VARFILES[@]}") ; done < <( _rfindfiles "$TF_AUTO_CONFIG_FILE.json" )
        while read -r LINE ; do BACKENDVARFILES=("$LINE" "${BACKENDVARFILES[@]}") ; done < <( _rfindfiles "$TF_BACKEND_AUTO_CONFIG_FILE" )
    fi
}
# This function takes an array and processes it for arguments from the Terraformsh
# command-line. First it grabs TFVARS files. Then it takes Terraform commands
# and arguments and splits theme up into pairs. The result is stuffed into the
# CMD_PAIRS global array, since we can't return arrays in Bash.
_process_cmds () {
    declare -a cmds=("$@")
    local s=0 p=0 found_cmds=0 cpi=0
    # First extract any TFVARS passed as initial arguments
    while [ $s -lt ${#cmds[@]} ] ; do
        cmd="${cmds[$s]}"
        # If a config file was passed as a command, add them as options
        if    [ ! "$(expr "$cmd" : ".*\.backend\.tfvars$")" = "0" ] \
              || [ ! "$(expr "$cmd" : ".*\.backend\.sh\.tfvars$")" = "0" ] \
              || [ ! "$(expr "$cmd" : ".*\.backend$")" = "0" ]
        then  BACKENDVARFILES+=("$(_readlinkf "$cmd")")
        elif  [ "$(expr "$cmd" : ".*\.tfvars$")" -ne 0 ] \
              || [ "$(expr "$cmd" : ".*\.sh\.tfvars$")" -ne 0 ] \
              || [ "$(expr "$cmd" : ".*\.tfvars\.json$")" -ne 0 ] \
              || [ "$(expr "$cmd" : ".*\.sh\.tfvars\.json$")" -ne 0 ]
        then  VARFILES+=("$(_readlinkf "$cmd")")
        else  break
        fi
        s=$((s+1))
    done
    # Then skip those TFVARS and start extracting commands and options, putting
    # them into arrays in CMD_PAIRS.
    cpi=${#CMD_PAIRS[@]} # Save this for later, in case this array was already
    p=$cpi               # populated before this function.
    prev='' prevcmd=''
    #for (( i = s; i < (${#cmds[@]}-s) ; i++ )) ; do
    for cmd in "${cmds[@]:$s}" ; do
        local valid_cmd=0
        for possiblecmd in "${TF_COMMANDS[@]}" "${WRAPPER_COMMANDS[@]}" ; do
            if [ "$possiblecmd" = "$cmd" ] ; then
                if [ "$prev" = "cmd" ] && declare -p "TF_CMDS_$prevcmd" 2>/dev/null 1>&2 ; then
                    declare -n arr="TF_CMDS_$prevcmd"
                    for subcmd in "${arr[@]}" ; do
                        [ "$subcmd" = "$cmd" ] && valid_cmd=2 && break
                    done
                fi
                [ $valid_cmd -eq 2 ] && break
                valid_cmd=1
                [ $found_cmds -gt 0 ] && p=$((p+1))
                break
            fi
        done
        if [ $valid_cmd -eq 0 ] || [ $valid_cmd -eq 2 ] ; then
            if [ $found_cmds -lt 1 ] ; then
                echo "$0: Error: Found non-command '$cmd' before a command was found" ; exit 1
            fi
            [ $valid_cmd -eq 0 ] && \
                echo "$0: Warning: '$cmd' is not a valid command; passing as an option instead" 1>&2
            [ $valid_cmd -eq 2 ] && \
                echo "$0: Warning: '$cmd' is a subcommand of previous command '$prevcmd'; passing as an option" 1>&2
            CMD_PAIRS[$p]+=" $(printf "%q" "$cmd")" # The space before \$( is intentional
            prev="opt"
        else
            echo "$0: Info: Found terraform command '$cmd'" 1>&2
            CMD_PAIRS[$p]="array=($(printf "%q" "$cmd")" # Yes this has a leading '('
            found_cmds=$((found_cmds+1))
            prev="cmd"
            prevcmd="$cmd"
        fi
    done
    for (( p = cpi; p < ${#CMD_PAIRS[@]}; p++ )) ; do
        CMD_PAIRS[$p]+=")"
    done
    if [ $(( ${#cmds[@]} - $s )) -lt 1 ] ; then
        echo "$0: Error: No COMMAND was specified"; echo ""; _usage
    fi
}
_dirchange () {
    if [ -n "${CD_DIR:-}" ] ; then
        printf "+ cd \"%s\"\n" "$CD_DIR" 1>&2
        cd "$CD_DIR"
    fi
}
_readlinkf () {
    [ "${1:-}" ] || return 1; m_s=40; CDPATH=''; t=$1; [ -e "${t%/}" ] || t=${1%"${1##*[!/]}"}
    [ -d "${t:-/}" ] && t="$t/"; cd -P . 2>/dev/null || return 1;
    while [ "$m_s" -ge 0 ] && m_s=$((m_s - 1)); do
      if [ ! "$t" = "${t%/*}" ]; then case $t in
        /*) cd -P "${t%/*}/"  || break ;;
        *) cd -P "./${t%/*}"  || break ;;
        esac; t=${t##*/}; fi
      if [ ! -L "$t" ]; then t="${PWD%/}${t:+/}${t}"; printf '%s\n' "${t:-/}"; return 0; fi
      link=$(ls -dl -- "$t" 2>/dev/null) || break; t=${link#*" $t -> "}
    done; return 1
}
_rfindfiles () {
    local file="$1"
    cwd="$(pwd)"
    while [ ! "$(dirname "$cwd")" = "/" ] ; do
        [ ! -e "$cwd/$file" ] || printf "%s\n" "$cwd/$file"
        cwd="$(dirname "$cwd")"
    done
}
_runcmd () {
    echo "+ $*" 1>&2
    if [ ! "${DRYRUN:-0}" = "1" ] ; then "$@"; fi
}

# ---------------------------------------------------------------------------------------- #
# ------------------           parse cmdline options           --------------------------- #

SHOW_HELP=0
declare -a BACKENDVARFILE_ARG=() BACKENDVARFILES=() VARFILE_ARG=() VARFILES=()
declare -a REFRESH_ARGS=() INIT_ARGS=() IMPORT_ARGS=() GET_ARGS=() STATE_ARGS=()
declare -a PLAN_ARGS=() APPLY_ARGS=() PLANDESTROY_ARGS=() DESTROY_ARGS=()
declare -a CONSOLE_ARGS=() TAINT_ARGS=() UNTAINT_ARGS=() OUTPUT_ARGS=()
declare -a FORCEUNLOCK_ARGS=()
declare -a CMDS=() CMD_PAIRS=() CONF_FILE=()

_default_vars

while getopts "f:b:C:c:E:IPDNnhv" args ; do
    case $args in
        f)  VARFILES+=("$(_readlinkf "$OPTARG")") ;;
        b)  BACKENDVARFILES+=("$(_readlinkf "$OPTARG")") ;;
        C)  CD_DIR="$OPTARG" ;;
        c)  CONF_FILE+=("$OPTARG") ;;
        E)  eval "$OPTARG" ;;
        I)  INHERIT_TFFILES=0 ;;
        P)  USE_PLANFILE=0 ;;
        D)  NO_DEP_CMDS=1 ;;
        N)  DRYRUN=1 ;;
        n)  NO_CLEANUP_TMP=1 ;;
        h)  SHOW_HELP=1 ;;
        v)  export DEBUG=1 ;;
        *)
            echo "$0: Error: unknown option $args" ; exit 1 ;;
    esac
done
shift $(($OPTIND-1))

[ $SHOW_HELP -eq 1 ] && _usage

# ---------------------------------------------------------------------------------------- #
# --------------------         run the commands            ------------------------------- #

[ "${DEBUG:-0}" = "1" ] && set -x

_load_parent_tffiles
_load_conf

[ ${#CMDS[@]} -eq 0 ] && CMDS=("$@")

_process_cmds "${CMDS[@]}"
_pre_dirchange_vars
_dirchange
_final_vars

declare -a array
for pair in "${CMD_PAIRS[@]}" ; do
    eval "$pair"
    name="${array[0]}" # array is defined in 'eval $pair'
    if command -v _cmd_"$name" >/dev/null ; then
        _cmd_"$name" "${array[@]:1}"
    else
        _cmd_catchall "$name" "${array[@]:1}"
    fi
done
